<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>PcbRouter代码阅读-网格表示 | Self Blogs</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="../../../../index.html">Self Blogs</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="../../../../index.html">Home</a></li><li><a class="nav" href="../../../../tags">Tags</a></li><li><a class="nav" href="../../../../categories">Categories</a></li><li><a class="nav" href="../../../../about">About</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> Jz-Wen 10 X 10</div></div><div id="code-pl">Jz-Wen:~/blog$
<span class="code-pl-input">source &quot;PcbRouter代码阅读-网格表示.sh&quot;</span><br><br>Jz-Wen:~/blog$
<span class="code-pl-input">printenv</span><br><span class="code-pl-output">CREATED_DATE = 2024-09-08</span><br><span class="code-pl-output">UPDATED_DATE = 2025-10-29</span><br><span class="code-pl-output">TAGS =</span><span class="code-pl-output"> </span><span class="code-pl-output"></span><br><span class="code-pl-output">CATEGORIES =</span><span class="code-pl-output"> </span><span class="code-pl-output"></span><br><br>Jz-Wen:~/blog$
<span class="code-pl-input">grep -lr $TAGS post</span><br><br><!--if page.next| > .prev
br
a(href=url_for(page.next.path))
  span.answer= page.next.title
br
br--><!--if page.prev| > .next
br
a(href=url_for(page.prev.path))
  span.answer= page.prev.title--></div></div></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">PcbRouter代码阅读-网格表示</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-09-08</time><p>首先来看一看基于网格的布线算法，<a target="_blank" rel="noopener" href="https://github.com/The-OpenROAD-Project/PcbRouter">The-OpenROAD-Project&#x2F;PcbRouter (github.com)</a>，该PCB布线器使用的是A*算法（后续结合论文来看）。</p>
<span id="more"></span>

<p>使用网格算法首先需要做的就是将物理坐标转化为栅格坐标，在这里计算出PCB板的长宽之后，乘了一个GlobalParam::inputScale变量，这个变量在项目中被设置为10，表示网格的精度（这里表示用0.1mm的宽度的网格），该数值越大精度就越大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GridBasedRouter::setupBoardGrid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n\n######Start of &quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">&quot;()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Get board dimension</span></span><br><span class="line">    <span class="comment">//mDb.getBoardBoundaryByPinLocation(this-&gt;mMinX, this-&gt;mMaxX, this-&gt;mMinY, this-&gt;mMaxY);</span></span><br><span class="line">    mDb.<span class="built_in">getBoardBoundaryByEdgeCuts</span>(<span class="keyword">this</span>-&gt;mMinX, <span class="keyword">this</span>-&gt;mMaxX, <span class="keyword">this</span>-&gt;mMinY, <span class="keyword">this</span>-&gt;mMaxY);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Routing Outline: (&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mMinX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mMinY &lt;&lt; <span class="string">&quot;), (&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mMaxX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mMaxY &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GlobalParam::inputScale: &quot;</span> &lt;&lt; GlobalParam::inputScale &lt;&lt; <span class="string">&quot;, GlobalParam::enlargeBoundary: &quot;</span> &lt;&lt; GlobalParam::enlargeBoundary &lt;&lt; <span class="string">&quot;, GlobalParam::gridFactor: &quot;</span> &lt;&lt; GlobalParam::gridFactor &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get grid dimension</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> h = <span class="built_in">int</span>(std::<span class="built_in">abs</span>(mMaxY * GlobalParam::inputScale - mMinY * GlobalParam::inputScale)) + GlobalParam::enlargeBoundary;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> w = <span class="built_in">int</span>(std::<span class="built_in">abs</span>(mMaxX * GlobalParam::inputScale - mMinX * GlobalParam::inputScale)) + GlobalParam::enlargeBoundary;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> l = mDb.<span class="built_in">getNumCopperLayers</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BoardGrid Size: w:&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;, h:&quot;</span> &lt;&lt; h &lt;&lt; <span class="string">&quot;, l:&quot;</span> &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize board grid</span></span><br><span class="line">    mBg.<span class="built_in">initilization</span>(w, h, l);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;######End of &quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">&quot;()\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其他地方的点数据，需要将db数据转化为网格数据，因此项目中也存在如下的转换接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GridBasedRouter::dbPointToGridPoint</span><span class="params">(<span class="type">const</span> point_2d &amp;dbPt, point_2d &amp;gridPt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> boundary checking</span></span><br><span class="line">    gridPt.m_x = dbPt.m_x * GlobalParam::inputScale - mMinX * GlobalParam::inputScale + GlobalParam::enlargeBoundary / <span class="number">2</span>;</span><br><span class="line">    gridPt.m_y = dbPt.m_y * GlobalParam::inputScale - mMinY * GlobalParam::inputScale + GlobalParam::enlargeBoundary / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">GridBasedRouter::<span class="built_in">gridPointToDbPoint</span>();</span><br><span class="line">GridBasedRouter::<span class="built_in">dbPointToGridPointRound</span>();</span><br><span class="line">GridBasedRouter::<span class="built_in">dbPointToGridPointFloor</span>();</span><br><span class="line">........</span><br></pre></td></tr></table></figure>



<p>如何存放生成的网格呢，在类中使用GridCell *grid来存放所有的网格，因此精度越高生成的网格越多，越占用内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoardGrid::initilization</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">    <span class="keyword">this</span>-&gt;h = h;</span><br><span class="line">    <span class="keyword">this</span>-&gt;l = l;</span><br><span class="line">    <span class="keyword">this</span>-&gt;size = w * h * l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;grid == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;grid = <span class="keyword">new</span> GridCell[<span class="keyword">this</span>-&gt;size];</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;grid != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">base_cost_fill</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// this-&gt;via_cost_fill(0.0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每一个GridCell里面存放有对应的Cost，用于启发式的计算，因此在布线过程中只需要改变这些网格的对应的Cost值就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GridCell</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ctor</span></span><br><span class="line">    <span class="built_in">GridCell</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//dtor</span></span><br><span class="line">    ~<span class="built_in">GridCell</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BoardGrid</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> baseCost = <span class="number">0.0</span>;     <span class="comment">//Record Routed Nets&#x27;s traces</span></span><br><span class="line">    <span class="type">float</span> workingCost = <span class="number">0.0</span>;  <span class="comment">//Walked Cost</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // Working cost breakdown</span></span><br><span class="line">    <span class="comment">// float overlappingCost = 0.0;  // cost of overlapping</span></span><br><span class="line">    <span class="comment">// float wirelengthCost = 0.0;   // walked distance</span></span><br><span class="line">    <span class="comment">// float historyCost = 0.0;      // overlapping/overflow cost from previous iteration</span></span><br><span class="line">    <span class="type">int</span> bendingCost = <span class="number">0.0</span>;  <span class="comment">// # Bending</span></span><br><span class="line">    <span class="comment">// int viaCost = 0.0;            // # Vias</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For incremental cost calculation</span></span><br><span class="line">    <span class="type">float</span> cachedTraceCost = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="type">float</span> cachedViaCost = <span class="number">-1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cameFromId = <span class="number">-1</span>;</span><br><span class="line">    GridCellType cellType = VACANT;</span><br><span class="line">    <span class="type">int</span> numTraces = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//bool targetedPin = false;</span></span><br><span class="line">    <span class="comment">//bool viaForbidden = false;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此整个结构就是BoardGrid下面管理了生成的GridCell的一片内存，再在BoardGrid封装改变GridCell中cost的方法。</p>
</article><article id="post"><script type="text/javascript" src="https://utteranc.es/client.js" repo="xxx/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></article><nav id="pagination"><div class="pagination clear-fix"><div class="page-prev pull-left"><a href="../../09/PCB-EDA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/"><i class="fa fa-chevron-left"> </i><span>PCB-EDA论文阅读1</span></a></div></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"></div><p class="design-info">Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://github.com/lazysheep666/terminal_theme" target="_blank">Teminal</a> (<a href="https://github.com/Tonny-Gu/terminal_theme" target="_blank">NekoDaemon Remix</a>)</p><p class="design-info"><a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a> 
Licensed | Copyright © 2025 Jz-Wen</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>